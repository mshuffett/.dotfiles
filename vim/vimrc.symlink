" vim: set sw=4 ts=4 sts=4 et tw=78 foldlevel=0 foldmethod=marker spell:

syntax on
set bg=dark
imap jk <esc>
set fen
"au BufWinLeave ?* mkview
"au BufWinEnter ?* silent loadview

if has('vim_starting')
    set nocompatible " Be iMproved

    " Required:
    set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" NeoBundle {{{
" Required:
" Note: You don't set neobundle setting in .gvimrc!
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle 'Shougo/vimproc.vim', {
			\ 'build' : {
			\     'windows' : 'tools\\update-dll-mingw',
			\     'cygwin' : 'make -f make_cygwin.mak',
			\     'mac' : 'make',
			\     'linux' : 'make',
			\     'unix' : 'gmake',
			\    },
			\ }

" NeoBundle 'Shougo/unite.vim'
" NeoBundle 'Shougo/neomru.vim'


NeoBundle 'wellle/targets.vim'
NeoBundle 'tpope/vim-rsi'
NeoBundle 'kchmck/vim-coffee-script'
NeoBundle 'carlosvillu/coffeScript-VIM-Snippets'
NeoBundle 'pangloss/vim-javascript'
NeoBundle 'gabrielelana/vim-markdown'
NeoBundle 'godlygeek/tabular'
NeoBundle 'bling/vim-airline'
NeoBundle 'gotgenes/vim-yapif'

NeoBundle 'tacahiroy/ctrlp-funky'
NeoBundle 'kien/rainbow_parentheses.vim'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-sleuth'
NeoBundle 'tpope/vim-repeat'
NeoBundle 'guns/vim-sexp'
NeoBundle 'tpope/vim-abolish'
NeoBundle 'nathanaelkane/vim-indent-guides'
" NeoBundle 'klen/python-mode'

" NeoBundle 'davidhalter/jedi-vim.git'
NeoBundle 'Shougo/neosnippet'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'Shougo/neocomplete'

NeoBundle 'mattn/emmet-vim'
let g:user_emmet_expandabbr_key = '<c-e>'
let g:use_emmet_complete_tag = 1

" Make very magic the default
NeoBundle 'coot/EnchantedVim'
NeoBundle 'coot/CRDispatcher'

NeoBundle 'tpope/vim-surround'
" NeoBundle 'Shougo/unite-outline'
" NeoBundle 'Valloric/YouCompleteMe'
NeoBundle 'kien/ctrlp.vim'
NeoBundle 'xolox/vim-easytags'
NeoBundle 'xolox/vim-misc'

NeoBundle 'AndrewRadev/linediff.vim'
NeoBundle 'mbbill/undotree'

NeoBundle 'spf13/vim-autoclose'
NeoBundle 'python-rope/ropevim'
NeoBundle 'Lokaltog/vim-easymotion'

NeoBundle 'tpope/vim-eunuch'

NeoBundle 'tpope/vim-unimpaired'
" NeoBundle 'scrooloose/nerdcommenter'
NeoBundle 'tpope/vim-commentary'
NeoBundle 'terryma/vim-multiple-cursors'
NeoBundle 'jmcantrell/vim-diffchanges'
NeoBundle 'vim-scripts/YankRing.vim'

NeoBundle 'scrooloose/syntastic'
NeoBundle 'wookiehangover/jshint.vim'
NeoBundle 'carlosvillu/coffeScript-VIM-Snippets'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'digitaltoad/vim-jade'


call neobundle#end()

" If there are uninstalled bundles found on
" startup,
" this will conveniently prompt you to install
" them.
NeoBundleCheck

" }}}

" Required:
filetype plugin indent on

let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
let g:indent_guides_auto_colors = 0
au FileType python IndentGuidesEnable
" indent-guides.vim
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd guibg=gray ctermbg=0
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=0

" NEOCOMPLETE SETTINGS {{{
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
let g:neocomplcache_force_overwrite_completefunc = 1
" let g:neocomplcache_force_omni_patterns['python'] = '[^. t].w*'
set ofu=syntaxcomplete#Complete
"au FileType python set omnifunc=pythoncomplete#Complete textwidth=0
autocmd FileType python setlocal omnifunc=RopeCompleteFunc
au FileType python let b:did_ftplugin = 1
" }}}

" Vim-jedi settings
let g:jedi#popup_on_dot = 0

" This lets you still see space in showcmd from http://superuser.com/a/693644/312157
"map <Space> <Leader>
let mapleader="\<SPACE>"
set showcmd
" For conflict
let loaded_alternateFile = 1
let DidEnhancedCommentify = 1

" Rainbow Parens
let g:rbpt_colorpairs = [
   \ [ '13', '#6c71c4'],
   \ [ '5',  '#d33682'],
   \ [ '1',  '#dc322f'],
   \ [ '9',  '#cb4b16'],
   \ [ '3',  '#b58900'],
   \ [ '2',  '#859900'],
   \ [ '6',  '#2aa198'],
   \ [ '4',  '#268bd2'],
   \ ]

au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

nmap <leader>nt :NERDTreeToggle<cr>

" CtrlP
nnoremap <leader>f :CtrlP<CR>
nnoremap <leader>b :CtrlPBuffer<CR>
" Make alignmaps not load because of conflicting keymap
let g:loaded_alignmaps = "v3d"
nnoremap <leader>m :CtrlPMRUFiles<CR>
nnoremap <leader>d :CtrlPBufTag<CR>

" Unite {{{
"let g:unite_source_history_yank_enable = 1
"nnoremap <Leader>/ :<C-u>Unite -no-split -silent -buffer-name=ag grep:.<CR>
"nnoremap <leader>s :<C-u>Unite -no-split -quick-match buffer<cr>
"nnoremap <leader>y :<C-u>Unite -no-split -buffer-name=yank    history/yank<cr>
"" nnoremap <leader>f :<C-u>Unite -no-split -buffer-name=files -start-insert file_rec/async:!<cr>
"nnoremap <leader>r :<C-u>Unite -no-split -buffer-name=mru -start-insert file_mru<cr>
"nnoremap <leader>o :<C-u>Unite -no-split -buffer-name=outline -start-insert outline<cr>

"if executable('ag')
    "" Use ag in unite grep source.
    "let g:unite_source_grep_command = 'ag'
    "let g:unite_source_grep_default_opts =
                "\ '-i --line-numbers --nocolor --nogroup --hidden --ignore ' .
                "\  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
    "let g:unite_source_grep_recursive_opt = ''
"elseif executable('pt')
    "" Use pt in unite grep source.
    "" https://github.com/monochromegane/the_platinum_searcher
    "let g:unite_source_grep_command = 'pt'
    "let g:unite_source_grep_default_opts = '-i --nogroup --nocolor'
    "let g:unite_source_grep_recursive_opt = ''
"elseif executable('ack-grep')
    "" Use ack in unite grep source.
    "let g:unite_source_grep_command = 'ack-grep'
    "let g:unite_source_grep_default_opts =
                "\ '-i --no-heading --no-color -k -H'
    "let g:unite_source_grep_recursive_opt = ''
"endif

"" Custom mappings for the unite buffer
"autocmd FileType unite call s:unite_settings()
"function! s:unite_settings()
    "" Play nice with supertab
    "" let b:SuperTabDisabled=1
    "" Enable navigation with control-j and control-k in insert mode
    "imap <buffer> <C-j>   <Plug>(unite_select_next_line)
    "imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
    "imap <silent><buffer><expr> <C-x> unite#do_action('split')
    "imap <silent><buffer><expr> <C-v> unite#do_action('vsplit')
    "imap <silent><buffer><expr> <C-t> unite#do_action('tabopen')

    "nmap <buffer> <ESC> <Plug>(unite_exit)
"endfunction
" }}}

colorscheme solarized
hi Normal ctermbg=NONE

" Setup the status line to display the tagname, if the taglist plugin has been loaded
autocmd VimEnter * try
autocmd VimEnter *   call Tlist_Get_Tagname_By_Line()
autocmd VimEnter *   set statusline=%f\ %y%{GetStatusEx()}[b:%n]\ [t:%{Tlist_Get_Tagname_By_Line()}]\ %m%r%=(%l/%L,%c%V)\ %P
autocmd VimEnter *   map <silent> <Leader>tap :TlistAddFilesRecursive . *pm<CR>
autocmd VimEnter * catch
autocmd VimEnter * endt

" Function for getting the file format and the encoding for the status line.
function! GetStatusEx()
    let str = ' [' . &fileformat
    if has('multi_byte') && &fileencoding != ''
        let str = str . ':' . &fileencoding
    endif
    let str = str . '] '
    return str
endfunction

set timeout

noremap <leader>q :q<CR>
noremap <leader>w :w<CR>

" Get rid of conflict
map <Plug>IMAP_NOJumpForward <Plug>IMAP_JumpForward

noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

" CtrlP
let g:ctrlp_working_path_mode = 'ra'

noremap <leader>ev :e ~/.vimrc<CR>

" linediff
noremap \ldt :Linediff<CR>
noremap \ldo :LinediffReset<CR>

set number " enable line numbers

set sw=4 ts=4 si ai

autocmd BufRead,BufNewFile   *.ion set noet ci pi sts=0 sw=4 ts=4

" Fix Regex
let g:VeryMagic = 0 " (default is 1)
let g:VeryMagicSubstitute = 1  " (default is 0)
let g:VeryMagicGlobal = 1  " (default is 0)
let g:VeryMagicVimGrep = 1  " (default is 0)
let g:VeryMagicSearchArg = 1  " (default is 0, :edit +/{pattern}))
let g:VeryMagicFunction = 1  " (default is 0, :fun /{pattern})
let g:VeryMagicHelpgrep = 1  " (default is 0)
let g:VeryMagicRange = 1  " (default is 0, search patterns in command ranges)
let g:VeryMagicEscapeBackslashesInSearchArg = 1  " (default is 0, :edit +/{pattern}))
let g:SortEditArgs = 1  " (default is 0, see below)
" TODO use easymotion for search
nm / /\v
nm ? ?\v

" xclip
map "+y :!xclip -f -sel clip<CR>
map "+p :r!xclip -o -sel clip<CR>

set history=10000

noremap <leader>gs :Gstatus<CR>
noremap <leader>gd :Gdiff<CR>
noremap <leader>gb :Gblame<CR>

" Trailing whitespace {{{
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Remove trailing whitespace before write
fun! <SID>StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun

autocmd BufWritePre * :call <SID>StripTrailingWhitespaces()
" }}}

" Keep visual mode selection after indenting
vmap > >gv
vmap < <gv

" Keep visual location after x
vnoremap x xgv<Esc>

function! YRRunAfterMaps()
	" Let Y be from point to end of line
    nnoremap Y :<C-U>YRYankCount 'y$'<CR>
	" Make visual yank maintain cursor position
	vnoremap y :YRYankRange 'v'<CR>gv<Esc>
endfunction
" Only search visually selected text
vnoremap / <Esc>/\%V\v
vnoremap ? <Esc>?\%V\v
set smartcase

" Persistent undo
if has("persistent_undo")
    set undodir=/home/$USER/.undodir/
    set undofile
endif


nnoremap <leader>u :UndotreeToggle<CR>
let g:yankring_paste_using_g = 0
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

" Don't pair quotes in vim files
let g:autoclose_vim_commentmode = 1

let g:easytags_cmd = '/apollo/env/envImprovement/bin/ctags'

" Jump to last line we were at
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

function! ShowTodos()
	set errorformat+=%f%*[\ ]%l%*[\ ]%m
	cex system('sed "s/(.*)[[:space:]]*//"', system('sed "s/.\{9\}//"', system('grep TODO', system('egrep "Michael\|Not Committed"', system('xargs -n1 git blame -f -n -w', system('git grep -l TODO'))))))
	"setlocal errorformat<
	copen
endfunction
nnoremap <leader>td :call ShowTodos()<CR>

":noremap <silent> - :call EnhancedCommentify('no', 'comment')<CR>j
":noremap <silent> _ :call EnhancedCommentify('no', 'decomment')<CR>j

" Work-around incomplete terminfo databases
" " Particulalry useful when under `screen`, which may or may not be attached to
" " a physical terminal capable of 256color mode.
if match($TERMCAP, 'Co#256:') == 0 || match($TERMCAP, ':Co#256:') > 0
   set t_Co=256
endif

" Python {{{
" ignore line too long errors
let g:pymode_lint_ignore = "E501"
" }}}

" set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo

set wildignore+=*.pyc,*/.git/*,*/.hg/*,*/.svn/*

" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

" Match tags in xml
runtime! macros/matchit.vim

" Autowrapping is annoying
set tw=0

" Sytastic {{{
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1
let g:syntastic_javascript_checkers = ['jshint']
let g:syntastic_python_checkers = ['prospector']
" }}}

" allow the . to execute once for each line of a visual selection
vnoremap . :normal .<CR>
vnoremap @q :normal @q<CR>

let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline_theme='molokai'

" save folding and cursor on exit
set viewoptions-=options " without this line it saves all old key bindings etc.
autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent loadview

" {{{ NeoSnippet
" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
"imap <expr><TAB>
" \ pumvisible() ? "\<C-n>" :
" \ neosnippet#expandable_or_jumpable() ?
" \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif
" }}}

" {{{ CtrlPFunky
nnoremap <Leader>o :CtrlPFunky<Cr>
" narrow the list down with a word under cursor
nnoremap <Leader>O :execute 'CtrlPFunky ' . expand('<cword>')<Cr>
let g:ctrlp_funky_matchtype = 'path'
let g:ctrlp_funky_syntax_highlight = 1
" }}}

let g:ropevim_autoimport_modules = ["os", "shutil", "sys"]

let g:easytags_async = 1

set hlsearch
" set foldlevelstart=99

" {{{ Markdown
let g:markdown_mapping_switch_status = '<Leader>x'
" }}}

au BufNewFile,BufRead *.lmx set filetype=xml
